Interfaces :
  List :
      ArrayList : (When size of the list known in while declaration);
                  Retrival/Insertion is O(1);
                  Use -> When index based retrival,efficient retrival needed.
      LinkedList : (When size of the list not known at declaration); Memory efficient.
                  Suitable for scenarios where you frequently need to insert or delete elements at the beginning or end of the list.
                  Provides constant-time insertions and deletions at the head and tail of the list (O(1)), but may have slower 
                  performance for random access by index (O(n)).
                  DoublyLinkedList :
                          Insertion and retrival can happen on both sides.
      Vector :
                Dynamic array like ArrayList.
                Provides Thread safe synchronized collection.
      Stack :
            Last in first out purpose.(LIFO);
            Synchronized and Thread safe. because it's the subclass of Vector class.
  Queue :
        Provides FIFO-First In First Out functionality.
        Implemented by LinkedList.
        
        PriorityQueue :
            Store elements based on its own priority.
            Default -> Ascending order. 
            Modified by using explicit comparator.
       Deque : (Double Ended Queue)
            Insertion and retrival happens on both side.
            ArrayDequeue : Perform well than LinkedList implementation.
            LinkedList : Prefer only More insertion /deletion takes place.
  Set :
       HashSet:
            Douplicates not allowd.
            there is no insertion order.
       LinkedHashSet :
            Douplicates not allowd.
            Insertion order followed.
            Time complexity => O(1) on average;
            Worst case => O(n) if collision occurs on hashing.
    SortedSet ;
        TreeSet :
            Douplicates not allowd.
            Elemention ordered in a sorted manner.
            SortedSet<Student> sortedSetByAge = new TreeSet<>(ageComparator);
    
